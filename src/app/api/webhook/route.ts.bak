import { NextRequest, NextResponse } from 'next/server';
import crypto from 'crypto';
import { FirestoreService } from '@/services/firestoreService';
import AIHealthService from '@/services/aiService';
import { storage } from '@/lib/firebase';
import { ref, uploadBytes, getDownloadURL } from 'firebase/storage';
import { admin } from '@/lib/firebase-admin';
import { createMealFlexMessage } from './new_flex_message';

export async function POST(request: NextRequest) {
  try {
    const body = await request.text();
    const signature = request.headers.get('x-line-signature') || '';
    
    // LINEç½²åã‚’æ¤œè¨¼
    if (!verifySignature(body, signature)) {
      return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });
    }

    const events = JSON.parse(body).events;

    // å„ã‚¤ãƒ™ãƒ³ãƒˆã‚’å‡¦ç†
    for (const event of events) {
      await handleEvent(event);
    }

    return NextResponse.json({ status: 'OK' });
  } catch (error) {
    console.error('Webhook error:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

function verifySignature(body: string, signature: string): boolean {
  const channelSecret = process.env.LINE_CHANNEL_SECRET;
  if (!channelSecret) return false;

  const hash = crypto
    .createHmac('sha256', channelSecret)
    .update(body, 'utf8')
    .digest('base64');

  return hash === signature;
}

async function handleEvent(event: any) {
  const { type, replyToken, source, message } = event;

  switch (type) {
    case 'message':
      await handleMessage(replyToken, source, message);
      break;
    case 'follow':
      await handleFollow(replyToken, source);
      break;
    case 'unfollow':
      console.log('User unfollowed:', source.userId);
      break;
    case 'postback':
      await handlePostback(replyToken, source, event.postback);
      break;
    default:
      console.log('Unknown event type:', type);
  }
}

async function handleMessage(replyToken: string, source: any, message: any) {
  const { userId } = source;
  
  switch (message.type) {
    case 'text':
      await handleTextMessage(replyToken, userId, message.text);
      break;
    case 'image':
      await handleImageMessage(replyToken, userId, message.id);
      break;
    default:
      await replyMessage(replyToken, [{
        type: 'text',
        text: 'ã™ã¿ã¾ã›ã‚“ã€ã“ã®ã‚¿ã‚¤ãƒ—ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã¯å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚'
      }]);
  }
}

async function handleTextMessage(replyToken: string, userId: string, text: string) {
  let responseMessage;

  // ä½“é‡è¨˜éŒ²ã®åˆ¤å®šï¼ˆæ•°å­—ã®ã¿ã¾ãŸã¯æ•°å­—+kgï¼‰
  const weightMatch = text.match(/^(\d{1,3}(?:\.\d+)?)\s*(?:kg)?$/);
  if (weightMatch) {
    const weight = parseFloat(weightMatch[1]);
    if (weight >= 20 && weight <= 300) { // å¦¥å½“ãªä½“é‡ç¯„å›²
      await recordWeight(userId, weight);
      responseMessage = {
        type: 'text',
        text: `ä½“é‡ ${weight}kg ã‚’è¨˜éŒ²ã—ã¾ã—ãŸï¼\n\nç¶™ç¶šçš„ãªè¨˜éŒ²ã§å¥åº·ç®¡ç†ã‚’é ‘å¼µã‚Šã¾ã—ã‚‡ã† ğŸ’ª`
      };
      await replyMessage(replyToken, [responseMessage]);
      return;
    }
  }

  // ã€Œè¨˜éŒ²ã€ãƒœã‚¿ãƒ³ã®å¿œç­”
  if (text === 'è¨˜éŒ²' || text.includes('è¨˜éŒ²')) {
    responseMessage = {
      type: 'template',
      altText: 'ä½•ã‚’è¨˜éŒ²ã—ã¾ã™ã‹ï¼Ÿ',
      template: {
        type: 'buttons',
        text: 'ä½•ã‚’è¨˜éŒ²ã—ã¾ã™ã‹ï¼Ÿ',
        actions: [
          {
            type: 'postback',
            label: 'ğŸ“Š ä½“é‡',
            data: 'action=record_weight'
          },
          {
            type: 'postback',
            label: 'ğŸ½ï¸ é£Ÿäº‹',
            data: 'action=record_meal'
          },
          {
            type: 'postback',
            label: 'ğŸƒâ€â™‚ï¸ é‹å‹•',
            data: 'action=record_exercise'
          }
        ]
      }
    };
    await replyMessage(replyToken, [responseMessage]);
    return;
  }

  // é£Ÿäº‹å†…å®¹ãŒå«ã¾ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆæ—¥æœ¬èªã®é£Ÿæãƒ»æ–™ç†åã‚’æ¤œå‡ºï¼‰
  if (text.includes('é£Ÿäº‹') || text.includes('æ–™ç†') || text.includes('ã”ã¯ã‚“') || 
      text.includes('é£Ÿã¹ãŸ') || text.includes('ãƒ‘ãƒ³') || text.includes('ç±³') ||
      text.includes('è‚‰') || text.includes('é­š') || text.includes('é‡èœ') ||
      /[ã‚¢-ãƒ³]{2,}/.test(text) || // ã‚«ã‚¿ã‚«ãƒŠæ–™ç†å
      /æœé£Ÿ|æ˜¼é£Ÿ|å¤•é£Ÿ|å¤œé£Ÿ|é–“é£Ÿ|ãŠã‚„ã¤/.test(text)) {
    
    // é£Ÿäº‹å†…å®¹ã‚’ä¸€æ™‚ä¿å­˜ï¼ˆpostbackã§ä½¿ç”¨ï¼‰
    await storeTempMealData(userId, text);
    
    responseMessage = {
      type: 'text',
      text: `ã€Œ${text.length > 20 ? text.substring(0, 20) + '...' : text}ã€\n\nã©ã†ã—ã¾ã™ã‹ï¼Ÿ`,
      quickReply: {
        items: [
          {
            type: 'action',
            action: {
              type: 'postback',
              label: 'é£Ÿäº‹ã‚’è¨˜éŒ²',
              data: 'action=save_meal'
            }
          },
          {
            type: 'action',
            action: {
              type: 'postback',
              label: 'ã‚«ãƒ­ãƒªãƒ¼ã‚’çŸ¥ã‚‹ã ã‘',
              data: 'action=analyze_meal'
            }
          }
        ]
      }
    };
  } else if (text.includes('ãƒ¬ãƒãƒ¼ãƒˆ') || text.includes('åˆ†æ') || text.includes('çµæœ')) {
    responseMessage = {
      type: 'template',
      altText: 'å¥åº·ãƒ¬ãƒãƒ¼ãƒˆã‚’ç¢ºèª',
      template: {
        type: 'buttons',
        text: 'å¥åº·ãƒ¬ãƒãƒ¼ãƒˆã‚’ç¢ºèªã—ã¾ã™ã‹ï¼Ÿ',
        actions: [
          {
            type: 'uri',
            label: 'ãƒ¬ãƒãƒ¼ãƒˆã‚’è¦‹ã‚‹',
            uri: `${process.env.NEXT_PUBLIC_APP_URL}/reports`
          }
        ]
      }
    };
  } else {
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¬ã‚¹ãƒãƒ³ã‚¹
    responseMessage = {
      type: 'template',
      altText: 'LINEå¥åº·ç®¡ç†ã‚¢ãƒ—ãƒª',
      template: {
        type: 'buttons',
        text: 'ã“ã‚“ã«ã¡ã¯ï¼ä½•ã‚’ãŠæ‰‹ä¼ã„ã—ã¾ã—ã‚‡ã†ã‹ï¼Ÿ',
        actions: [
          {
            type: 'postback',
            label: 'ğŸ“ è¨˜éŒ²ã™ã‚‹',
            data: 'action=start_record'
          },
          {
            type: 'uri',
            label: 'ğŸ“± ã‚¢ãƒ—ãƒªã‚’é–‹ã',
            uri: process.env.NEXT_PUBLIC_LIFF_ID ? `https://liff.line.me/${process.env.NEXT_PUBLIC_LIFF_ID}` : process.env.NEXT_PUBLIC_APP_URL || ''
          },
          {
            type: 'postback',
            label: 'ğŸ“Š ä»Šæ—¥ã®è¨˜éŒ²ã‚’è¦‹ã‚‹',
            data: 'action=today_summary'
          }
        ]
      }
    };
  }

  await replyMessage(replyToken, [responseMessage]);
}

async function handleImageMessage(replyToken: string, userId: string, messageId: string) {
  try {
    // ç”»åƒã‚’å–å¾—ã—ã¦AIè§£æ
    const imageContent = await getImageContent(messageId);
    if (!imageContent) {
      await replyMessage(replyToken, [{
        type: 'text',
        text: 'ç”»åƒã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚'
      }]);
      return;
    }

    // é£Ÿäº‹ç”»åƒã‚’ä¸€æ™‚ä¿å­˜
    await storeTempMealData(userId, '', imageContent);

    const responseMessage = {
      type: 'text',
      text: 'é£Ÿäº‹å†™çœŸã‚’å—ã‘å–ã‚Šã¾ã—ãŸï¼\nAIã§åˆ†æã—ã¾ã™ã‹ï¼Ÿ',
      quickReply: {
        items: [
          {
            type: 'action',
            action: {
              type: 'postback',
              label: 'é£Ÿäº‹ã‚’è¨˜éŒ²',
              data: 'action=save_meal_image'
            }
          },
          {
            type: 'action',
            action: {
              type: 'postback',
              label: 'ã‚«ãƒ­ãƒªãƒ¼ã‚’çŸ¥ã‚‹ã ã‘',
              data: 'action=analyze_meal_image'
            }
          }
        ]
      }
    };

    await replyMessage(replyToken, [responseMessage]);
  } catch (error) {
    console.error('ç”»åƒå‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
    await replyMessage(replyToken, [{
      type: 'text',
      text: 'ç”»åƒã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚'
    }]);
  }
}

async function handleFollow(replyToken: string, source: any) {
  const { userId } = source;
  
  // æ–°è¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å ´åˆã€ã‚«ã‚¦ãƒ³ã‚»ãƒªãƒ³ã‚°ã¸èª˜å°
  const welcomeMessage = {
    type: 'template',
    altText: 'LINEå¥åº·ç®¡ç†ã¸ã‚ˆã†ã“ãï¼',
    template: {
      type: 'buttons',
      text: 'LINEå¥åº·ç®¡ç†ã¸ã‚ˆã†ã“ãï¼\n\nã‚ãªãŸå°‚ç”¨ã®å¥åº·ãƒ—ãƒ©ãƒ³ã‚’ä½œæˆã—ã¾ã›ã‚“ã‹ï¼Ÿ',
      actions: [
        {
          type: 'uri',
          label: 'ã‚«ã‚¦ãƒ³ã‚»ãƒªãƒ³ã‚°é–‹å§‹',
          uri: process.env.NEXT_PUBLIC_LIFF_ID ? `https://liff.line.me/${process.env.NEXT_PUBLIC_LIFF_ID}/counseling` : `${process.env.NEXT_PUBLIC_APP_URL}/counseling`
        }
      ]
    }
  };

  await replyMessage(replyToken, [welcomeMessage]);
}

async function replyMessage(replyToken: string, messages: any[]) {
  const accessToken = process.env.LINE_CHANNEL_ACCESS_TOKEN;
  
  if (!accessToken) {
    console.error('LINE_CHANNEL_ACCESS_TOKEN is not set');
    return;
  }

  try {
    const response = await fetch('https://api.line.me/v2/bot/message/reply', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${accessToken}`,
      },
      body: JSON.stringify({
        replyToken,
        messages,
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      console.error('Failed to reply message:', error);
    }
  } catch (error) {
    console.error('Error replying message:', error);
  }
}

// ãƒ—ãƒƒã‚·ãƒ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ç”¨ã®é–¢æ•°ï¼ˆä»–ã®APIã‹ã‚‰å‘¼ã³å‡ºã—å¯èƒ½ï¼‰
export async function pushMessage(userId: string, messages: any[]) {
  const accessToken = process.env.LINE_CHANNEL_ACCESS_TOKEN;
  
  if (!accessToken) {
    console.error('LINE_CHANNEL_ACCESS_TOKEN is not set');
    return;
  }

  try {
    const response = await fetch('https://api.line.me/v2/bot/message/push', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${accessToken}`,
      },
      body: JSON.stringify({
        to: userId,
        messages,
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      console.error('Failed to push message:', error);
    }
  } catch (error) {
    console.error('Error pushing message:', error);
  }
}

// Postbackå‡¦ç†
async function handlePostback(replyToken: string, source: any, postback: any) {
  const { userId } = source;
  const { data } = postback;
  
  const params = new URLSearchParams(data);
  const action = params.get('action');

  switch (action) {
    case 'start_record':
      // è¨˜éŒ²ãƒœã‚¿ãƒ³ã¨åŒã˜å‡¦ç†
      await replyMessage(replyToken, [{
        type: 'template',
        altText: 'ä½•ã‚’è¨˜éŒ²ã—ã¾ã™ã‹ï¼Ÿ',
        template: {
          type: 'buttons',
          text: 'ä½•ã‚’è¨˜éŒ²ã—ã¾ã™ã‹ï¼Ÿ',
          actions: [
            {
              type: 'postback',
              label: 'ğŸ“Š ä½“é‡',
              data: 'action=record_weight'
            },
            {
              type: 'postback',
              label: 'ğŸ½ï¸ é£Ÿäº‹',
              data: 'action=record_meal'
            },
            {
              type: 'postback',
              label: 'ğŸƒâ€â™‚ï¸ é‹å‹•',
              data: 'action=record_exercise'
            }
          ]
        }
      }]);
      break;

    case 'record_weight':
      await replyMessage(replyToken, [{
        type: 'text',
        text: 'ä½“é‡ã‚’æ•°å­—ã§æ•™ãˆã¦ãã ã•ã„ï¼ˆä¾‹ï¼š65.5 ã¾ãŸã¯ 65.5kgï¼‰'
      }]);
      break;

    case 'record_meal':
      await replyMessage(replyToken, [{
        type: 'text',
        text: 'é£Ÿäº‹å†…å®¹ã‚’æ•™ãˆã¦ãã ã•ã„ã€‚\nãƒ†ã‚­ã‚¹ãƒˆã¾ãŸã¯å†™çœŸã§é€ã£ã¦ãã ã•ã„ï¼\n\nä¾‹ï¼šã€Œæœé£Ÿï¼šãƒ‘ãƒ³ã¨ã‚³ãƒ¼ãƒ’ãƒ¼ã€'
      }]);
      break;

    case 'record_exercise':
      await replyMessage(replyToken, [{
        type: 'text',
        text: 'é‹å‹•è¨˜éŒ²æ©Ÿèƒ½ã¯æº–å‚™ä¸­ã§ã™ï¼\nã‚‚ã†ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ ğŸƒâ€â™‚ï¸'
      }]);
      break;

    case 'save_meal':
    case 'save_meal_image':
      // é£Ÿäº‹ã‚’è¨˜éŒ²ã™ã‚‹ - é£Ÿäº‹ã‚¿ã‚¤ãƒ—é¸æŠ
      await showMealTypeSelection(replyToken);
      break;

    case 'analyze_meal':
    case 'analyze_meal_image':
      // ã‚«ãƒ­ãƒªãƒ¼åˆ†æã®ã¿
      await analyzeMealOnly(userId, replyToken);
      break;

    case 'meal_breakfast':
    case 'meal_lunch':
    case 'meal_dinner':
    case 'meal_snack':
      const mealType = action.replace('meal_', '');
      await saveMealRecord(userId, mealType, replyToken);
      break;

    default:
      console.log('Unknown postback action:', action);
  }
}

// é£Ÿäº‹ã‚¿ã‚¤ãƒ—é¸æŠç”»é¢
async function showMealTypeSelection(replyToken: string) {
  const responseMessage = {
    type: 'text',
    text: 'ã©ã®é£Ÿäº‹ã‚’è¨˜éŒ²ã—ã¾ã™ã‹ï¼Ÿ',
    quickReply: {
      items: [
        {
          type: 'action',
          action: {
            type: 'postback',
            label: 'æœé£Ÿ',
            data: 'action=meal_breakfast'
          }
        },
        {
          type: 'action',
          action: {
            type: 'postback',
            label: 'æ˜¼é£Ÿ',
            data: 'action=meal_lunch'
          }
        },
        {
          type: 'action',
          action: {
            type: 'postback',
            label: 'å¤•é£Ÿ',
            data: 'action=meal_dinner'
          }
        },
        {
          type: 'action',
          action: {
            type: 'postback',
            label: 'é–“é£Ÿ',
            data: 'action=meal_snack'
          }
        }
      ]
    }
  };
  
  await replyMessage(replyToken, [responseMessage]);
}

// ä½“é‡è¨˜éŒ²
async function recordWeight(userId: string, weight: number) {
  try {
    const firestoreService = new FirestoreService();
    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    await firestoreService.updateWeight(userId, today, weight);
    console.log(`ä½“é‡è¨˜éŒ²å®Œäº†: ${userId}, ${weight}kg`);
  } catch (error) {
    console.error('ä½“é‡è¨˜éŒ²ã‚¨ãƒ©ãƒ¼:', error);
  }
}

// ä¸€æ™‚çš„ãªé£Ÿäº‹ãƒ‡ãƒ¼ã‚¿ä¿å­˜ï¼ˆãƒ¡ãƒ¢ãƒªï¼‰
const tempMealData = new Map<string, { text?: string; image?: Buffer; timestamp: number }>();

async function storeTempMealData(userId: string, text: string, image?: Buffer) {
  tempMealData.set(userId, {
    text,
    image,
    timestamp: Date.now()
  });
  
  // 10åˆ†å¾Œã«ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤
  setTimeout(() => {
    tempMealData.delete(userId);
  }, 10 * 60 * 1000);
}

// é£Ÿäº‹å†…å®¹ã®AIåˆ†æï¼ˆã‚«ãƒ­ãƒªãƒ¼ã®ã¿ï¼‰
async function analyzeMealOnly(userId: string, replyToken: string) {
  try {
    const tempData = tempMealData.get(userId);
    if (!tempData) {
      await replyMessage(replyToken, [{
        type: 'text',
        text: 'ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ã‚‚ã†ä¸€åº¦é£Ÿäº‹å†…å®¹ã‚’é€ã£ã¦ãã ã•ã„ã€‚'
      }]);
      return;
    }

    const aiService = new AIHealthService();
    let analysis;

    if (tempData.image) {
      // ç”»åƒåˆ†æ
      analysis = await aiService.analyzeMealFromImage(tempData.image);
    } else {
      // ãƒ†ã‚­ã‚¹ãƒˆåˆ†æ
      analysis = await aiService.analyzeMealFromText(tempData.text || '');
    }

    const message = `ğŸ“Š ã‚«ãƒ­ãƒªãƒ¼åˆ†æçµæœ\n\nğŸ½ï¸ é£Ÿäº‹å†…å®¹: ${analysis.foodItems.join(', ')}\n\nğŸ“ˆ æ „é¤Šæƒ…å ±:\nãƒ»ã‚«ãƒ­ãƒªãƒ¼: ${analysis.calories}kcal\nãƒ»ã‚¿ãƒ³ãƒ‘ã‚¯è³ª: ${analysis.protein}g\nãƒ»è„‚è³ª: ${analysis.fat}g\nãƒ»ç‚­æ°´åŒ–ç‰©: ${analysis.carbs}g`;

    await replyMessage(replyToken, [{
      type: 'text',
      text: message
    }]);

    // ä¸€æ™‚ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤
    tempMealData.delete(userId);

  } catch (error) {
    console.error('é£Ÿäº‹åˆ†æã‚¨ãƒ©ãƒ¼:', error);
    await replyMessage(replyToken, [{
      type: 'text',
      text: 'åˆ†æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚'
    }]);
  }
}

// é£Ÿäº‹è¨˜éŒ²ã‚’ä¿å­˜
async function saveMealRecord(userId: string, mealType: string, replyToken: string) {
  try {
    const tempData = tempMealData.get(userId);
    if (!tempData) {
      await replyMessage(replyToken, [{
        type: 'text',
        text: 'ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ã‚‚ã†ä¸€åº¦é£Ÿäº‹å†…å®¹ã‚’é€ã£ã¦ãã ã•ã„ã€‚'
      }]);
      return;
    }

    const aiService = new AIHealthService();
    let analysis;

    if (tempData.image) {
      analysis = await aiService.analyzeMealFromImage(tempData.image);
    } else {
      analysis = await aiService.analyzeMealFromText(tempData.text || '');
    }

    // Firestoreã«ä¿å­˜
    const firestoreService = new FirestoreService();
    const today = new Date().toISOString().split('T')[0];
    
    // ç”»åƒãŒã‚ã‚‹å ´åˆã¯åœ§ç¸®ã—ã¦ä¸€æ™‚ä¿å­˜ã—ã€å¤–éƒ¨URLã§æä¾›
    let imageUrl = null;
    let imageId = null;
    if (tempData.image) {
      try {
        const sharp = require('sharp');
        
        // ç”»åƒã‚’åœ§ç¸®ï¼ˆ200x200ãƒ”ã‚¯ã‚»ãƒ«ã€å“è³ª60%ï¼‰
        const compressedImage = await sharp(tempData.image)
          .resize(200, 200, { fit: 'cover' })
          .jpeg({ quality: 60 })
          .toBuffer();
        
        // Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
        const base64Data = compressedImage.toString('base64');
        
        // ä¸€æ„ã®IDã‚’ç”Ÿæˆ
        imageId = `meal_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        // Firestoreã®ç”»åƒã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«ä¸€æ™‚ä¿å­˜
        await admin.firestore()
          .collection('images')
          .doc(imageId)
          .set({
            base64Data: `data:image/jpeg;base64,${base64Data}`,
            mimeType: 'image/jpeg',
            createdAt: new Date(),
            userId: userId
          });
        
        // ãƒ†ã‚¹ãƒˆç”¨ã«Unsplashç”»åƒã‚’ä½¿ç”¨ï¼ˆä¸€æ™‚çš„ï¼‰
        imageUrl = 'https://images.unsplash.com/photo-1546554137-f86b9593a222?w=200&h=200&fit=crop';
        
        console.log(`ç”»åƒåœ§ç¸®å®Œäº†: ${tempData.image.length} bytes â†’ ${compressedImage.length} bytes`);
        console.log(`ãƒ†ã‚¹ãƒˆç”»åƒURLä½¿ç”¨: ${imageUrl}`);
      } catch (error) {
        console.error('ç”»åƒå‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”»åƒã‚’ä½¿ç”¨
        imageUrl = 'https://images.unsplash.com/photo-1546554137-f86b9593a222?w=400&h=400&fit=crop';
        console.log('âš ï¸ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”»åƒURLä½¿ç”¨:', imageUrl);
      }
    }
    
    const mealData = {
      id: Date.now().toString(),
      name: analysis.foodItems.join(', ') || 'é£Ÿäº‹',
      mealTime: mealType as 'breakfast' | 'lunch' | 'dinner' | 'snack',
      time: new Date().toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' }),
      type: mealType,
      items: analysis.foodItems,
      calories: analysis.calories,
      protein: analysis.protein,
      fat: analysis.fat,
      carbs: analysis.carbs,
      foodItems: analysis.foodItems,
      images: imageUrl ? [imageUrl] : [],
      image: imageUrl,
      timestamp: new Date()
    };

    await firestoreService.addMeal(userId, today, mealData);

    const mealTypeJa = {
      breakfast: 'æœé£Ÿ',
      lunch: 'æ˜¼é£Ÿ', 
      dinner: 'å¤•é£Ÿ',
      snack: 'é–“é£Ÿ'
    }[mealType] || 'é£Ÿäº‹';

    // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆé€šã‚Šã®ã‚·ãƒ³ãƒ—ãƒ«ãªFlexãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    const flexMessage = createMealFlexMessage(mealTypeJa, analysis, imageUrl);
          contents: [
            // é£Ÿäº‹ã‚¿ã‚¤ãƒˆãƒ«
            {
              type: 'text',
              text: mealTypeJa,
              size: 'xl',
              weight: 'bold',
              color: '#333333'
            },
            // é£Ÿäº‹åã¨æ™‚é–“
            {
              type: 'box',
              layout: 'horizontal',
              margin: 'md',
              contents: [
                {
                  type: 'text',
                  text: analysis.foodItems.join(', '),
                  size: 'lg',
                  weight: 'bold',
                  color: '#333333',
                  flex: 1
                },
                {
                  type: 'text',
                  text: new Date().toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' }),
                  size: 'sm',
                  color: '#999999',
                  align: 'end'
                }
              ]
            },
            // ç”»åƒè¡¨ç¤ºï¼ˆå¤–éƒ¨URLã‚’ä½¿ç”¨ï¼‰
            ...(imageUrl && !imageUrl.startsWith('data:image') ? [{
              type: 'image',
              url: imageUrl,
              size: 'full',
              aspectRatio: '1:1',
              aspectMode: 'cover',
              backgroundColor: '#f5f5f5',
              margin: 'md'
            }] : imageUrl && imageUrl.startsWith('data:image') ? [{
              type: 'text',
              text: 'ğŸ“¸ ç”»åƒä»˜ãã§è¨˜éŒ²ã•ã‚Œã¾ã—ãŸ',
              size: 'sm',
              color: '#666666',
              align: 'center',
              margin: 'md'
            }] : []),
            // PFCãƒãƒƒã‚¸ï¼ˆã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã®ã‚ˆã†ã«ï¼‰
            {
              type: 'box',
              layout: 'horizontal',
              margin: 'md',
              spacing: 'sm',
              contents: [
                {
                  type: 'box',
                  layout: 'vertical',
                  cornerRadius: '12px',
                  paddingAll: '8px',
                  flex: 1,
                  backgroundColor: '#ff6b6b',
                  contents: [
                    {
                      type: 'text',
                      text: `P: ${analysis.protein}g`,
                      size: 'sm',
                      color: '#ffffff',
                      weight: 'bold',
                      align: 'center'
                    }
                  ]
                },
                {
                  type: 'box',
                  layout: 'vertical',
                  cornerRadius: '12px',
                  paddingAll: '8px',
                  flex: 1,
                  backgroundColor: '#ffa726',
                  contents: [
                    {
                      type: 'text',
                      text: `F: ${analysis.fat}g`,
                      size: 'sm',
                      color: '#ffffff',
                      weight: 'bold',
                      align: 'center'
                    }
                  ]
                },
                {
                  type: 'box',
                  layout: 'vertical',
                  cornerRadius: '12px',
                  paddingAll: '8px',
                  flex: 1,
                  backgroundColor: '#66bb6a',
                  contents: [
                    {
                      type: 'text',
                      text: `C: ${analysis.carbs}g`,
                      size: 'sm',
                      color: '#ffffff',
                      weight: 'bold',
                      align: 'center'
                    }
                  ]
                }
              ]
            },
            // ã‚«ãƒ­ãƒªãƒ¼ï¼ˆå¤§ããé’ã§ï¼‰
            {
              type: 'text',
              text: `${analysis.calories}kcal`,
              size: 'xxl',
              weight: 'bold',
              color: '#4a90e2',
              align: 'center',
              margin: 'lg'
            },
            // AIåˆ†æã‚³ãƒ¡ãƒ³ãƒˆ
            {
              type: 'text',
              text: `AIï¼šæ „é¤Šãƒãƒ©ãƒ³ã‚¹ã¯æ¯”è¼ƒçš„è‰¯ã„ã§ã™ãŒã€è„‚è³ªã‚’æ§ãˆã‚ã«ã—ã€é‡èœã‚’å¢—ã‚„ã™ã“ã¨ã§ã€ã•ã‚‰ã«ãƒ˜ãƒ«ã‚·ãƒ¼ã«ãªã‚Šã¾ã™ã€‚ã‚«ãƒ­ãƒªãƒ¼ã‚’æŠ‘ãˆãŸã„å ´åˆã¯ã€ãƒ‰ãƒ¬ãƒƒã‚·ãƒ³ã‚°ã®é‡ã‚’æ¸›ã‚‰ã™ã‹ã€ä½ã‚«ãƒ­ãƒªãƒ¼ã®ã‚‚ã®ã‚’ä½¿ç”¨ã—ã¾ã—ã‚‡ã†ã€‚`,
              size: 'sm',
              color: '#666666',
              wrap: true,
              margin: 'lg'
            }
          ]
        }
      }
    };

    await replyMessage(replyToken, [flexMessage]);

    // ä¸€æ™‚ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤
    tempMealData.delete(userId);

  } catch (error) {
    console.error('é£Ÿäº‹è¨˜éŒ²ã‚¨ãƒ©ãƒ¼:', error);
    await replyMessage(replyToken, [{
      type: 'text',
      text: 'è¨˜éŒ²ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚'
    }]);
  }
}

// LINEç”»åƒå–å¾—
async function getImageContent(messageId: string): Promise<Buffer | null> {
  const accessToken = process.env.LINE_CHANNEL_ACCESS_TOKEN;
  if (!accessToken) return null;

  try {
    const response = await fetch(`https://api-data.line.me/v2/bot/message/${messageId}/content`, {
      headers: {
        'Authorization': `Bearer ${accessToken}`,
      },
    });

    if (!response.ok) return null;
    
    const arrayBuffer = await response.arrayBuffer();
    return Buffer.from(arrayBuffer);
  } catch (error) {
    console.error('ç”»åƒå–å¾—ã‚¨ãƒ©ãƒ¼:', error);
    return null;
  }
}